// [1,3,5,4,2]，从右往左，[4,2]已经最大，[5,4,2]同理。观察[3,5,4,2]，发现3的右边有比他大的数，于是把4挪过去，因为4比3大一点
// 如果把5挪过去，就不是下一个排列了。剩下2,3,5，从小到大排序即可。
// 这个过程其实分三步，1.从右到左找到第一个非逆序对 2.找到第一个比他大的数，这其实很好找，因为从右往左是单调递增的，所以扫一遍
// 就找到了，再交换两者右边依然是单调递增的 3.既然本身就有单调性了，直接reverse就可以变成单调递减了

func nextPermutation(nums []int)  {
    n := len(nums)

    i := n - 2
    for i >= 0 && nums[i] >= nums[i + 1] { // 防止越界
        i--
    }

    if i >= 0 { // 如果i是-1，全部都是逆序的，依照题意直接reverse即可
        j := n - 1
        for nums[i] >= nums [j] {
            j--
        }
        nums[i], nums[j] = nums[j], nums[i]
    }

    slices.Reverse(nums[i + 1:])
}

// 示例 1：
// 输入：nums = [1,2,3]
// 输出：[1,3,2]


// 示例 2：
// 输入：nums = [3,2,1]
// 输出：[1,2,3]


// 示例 3：
// 输入：nums = [1,1,5]
// 输出：[1,5,1]