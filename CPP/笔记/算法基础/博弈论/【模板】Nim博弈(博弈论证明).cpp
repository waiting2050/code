// Nim博弈的结论
// Nim 博弈的胜负策略通常依赖于 尼姆和（Nim-sum），即所有堆石子数量的异或（XOR）值。如果游戏开始时的尼姆和为 0
// 则先手必败；否则，先手必胜。

// 结论的证明
// 这个证明过程非常重要，是理解Nim博弈以及后面的SG函数的关键，需要读者慢慢理解。
// 对于博弈中的结论，我们一般是直接抛出定义，后来通过
// 3个关键条件来证明：
//（1）最终态的归属，是属于必胜态还是必败态。
//（2）必胜态存在至少一种方案转移到必败态（给对手）。
//（3）必败态的所有方案都只能转移到必胜态（给对手）。

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;

void solve()
{
	int n; cin >> n;
	
	int res = 0;
	for(int i = 1; i <= n; i++)
	{
		int x; cin >> x;
		res ^= x;
	}
	
	cout << (res ? "YES" : "NO") << '\n';
}

int main()
{
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	
	int _; cin >> _;
	while(_--) solve();

	return 0;
}

// 我们根据一个数组的异或和来设定两种状态：
// 必胜态：数组异或和非0。
// 必败态：数组异或和为0。
// 这里最终态（全0的数组，异或和为0）是必败态，显然，也符合Nim游戏的定义。

// 现在只需要证明两件事：“必胜态至少存在一种方案转移到必败态（使得对手必败，即自身必胜）”和“必败态无论如何只能转移给必胜态（对手必胜，于是自己必败）”。只要能证明这件事儿，就说明这两种状态的划分是正确的。
// 竞赛笔记：博弈的基础是“玩家足够聪明，每次操作都会选择对自己最有利的”，于是玩家若处于必胜态（异或和不为0）。

// 【证明1】必败态转移为必胜态：
// 这个比较容易，对于一个异或和为0的数组，将其中某一位减少一些（或变为0），必然使得整个数组异或和不为0。
// 举个例子，假如说有数组[a₁, a₂, a₃, a₄]，其异或和为0，假设我选中的数字是a₃，我要将其变小一些（或变为0）。操作前有a₁⊕a₂⊕a₄ = a₃，也就是说如果要继续保持整个数组异或和为0，那么a₃就不能变化，但是a₃又不得不变化，于是整个数组的异或和一定变为非0。

// 【证明2】必胜态转移为必败态：
// 这个稍微要复杂一些，假如现在有一个异或和非0的数组，有a₁⊕a₂⊕…⊕aₙ = x ≠ 0，设x的最高位1所在位数为k，那么在a₁～aₙ中至少存在一个aᵢ的二进制第k位为1（若不存在，x第k位的1就没人提供啦！）。
// 于是有aᵢ > aᵢ⊕x（因为aᵢ和x的二进制最高位相同，异或之后最高位从1变0，于是结果肯定小于aᵢ）。设y = aᵢ - (aᵢ⊕x) > 0，我们只需要让aᵢ减去y即可，也就是aᵢ变为aᵢ - y = aᵢ - (aᵢ - (aᵢ⊕x)) = aᵢ⊕x，于是使得数组异或和为0。
// 实际上这可证明存在aᵢ > aᵢ⊕x就可以直接让aᵢ变为aᵢ⊕x。