// 题目对空间和时间的要求比较严格，首先如果不限制空间，用一个桶计数，看看哪个值对应个数为0就是答案，但是要怎么加上对空间的限制呢？
// 这里用到了原地哈希算法，用数组本身作为桶，但是不能做过多更改，于是用swap去维护位置与数值的对应关系。
// 首先定义对应关系，0->1,1->2，即下标到值的映射；然后遍历数组，只处理合法区间的数，即[1,n]的数，并且不重复交换，比如两个位置的
// 数的数值是相同的，防止无限原地tp。相当于每次交换位置都是开盲盒，数组左边的数与某个数做交换，但是一旦某个位置的映射正确确定下来，那么
// 这个位置就不会再动了，时间复杂度是O(N)。

class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();

        for(int i = 0; i < n; ++i)
            while(nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1])
                swap(nums[i], nums[nums[i] - 1]);

        for(int i = 0; i < n; ++i)  if(nums[i] != i + 1) return i + 1;
        return n + 1;
    }
};


// 示例 1：
// 输入：nums = [1,2,0]
// 输出：3
// 解释：范围 [1,2] 中的数字都在数组中。


// 示例 2：
// 输入：nums = [3,4,-1,1]
// 输出：2
// 解释：1 在数组中，但 2 没有。


// 示例 3：
// 输入：nums = [7,8,9,11,12]
// 输出：1
// 解释：最小的正数 1 没有出现。