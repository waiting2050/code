// 树形dp一般分为自下而上和换根dp，区别在于转移的方向不同
// 本题为自下而上树形dp，自下而上的树形dp状态转移一般发生在子节点全部计算完毕后（第一类转移），或计算过程中（第二类转移，此时dp[x]的信息并不完全，表示的应该是x与若干子节点的信息，而不是x整个子树的信息），后者的题目会比前者难一些，也更难理解。
// void dfs(int x, int fa)
// {
//     for(const auto &y : g[x])
//     {
//         if(y == fa)continue;//保证不往回走
//         dfs(y, x);
//         //第二类转移的位置，此时dp[x]表示的信息是x与若干子节点的信息
//     }
//     //第一类转移的位置
// }

// 第一类转移
// 第一类转移就是完全通过子节点来更新父节点，且要求子节点之间互相不影响。例如求子树大小，就可以将所有子节点的子树大小加起来再+1得到当前子树大小。求最大深度，就是将所有子节点的子树最大深度+1即可。
// 如图，为了得到结点6的信息，我们分别用5更新6，用8更新6，用9更新6。

// 第二类转移
// 第二类转移中，子节点之间互相影响，如果继续采用第一类转移的方式来做，复杂度较高，转移的复杂度可能退化到O（n²），n为子节点个数。
// 例如要求以x为根的子树中经过根的最长链的长度，此时需要选择两个不同的子节点来计算结果，如果在计算完所有子节点信息后，暴力枚举子节点的话，时间复杂度很高。
// 于是我们可以考虑，在过程中（过程中dp[x」信息不完全，表示的是x与部分子节点的信息）去转移，这和我们解决一些数组上的dp问题优化思路很像。经过这个操作，可以让转移的时间复杂度降低到O(n)。
// 如图，我们每次都是用绿色部分信息和红色部分信息结合起来来更新红色部分信息，从而是的红色部分信息（即dp[x]）的范围不断变大，直到覆盖整个x子树。

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;
#define pb push_back

const int N = 6e3 + 7;

vector<int> g[N];
ll r[N],dp[N][2], fa[N];

void dfs(int x)
{
	for(auto& y : g[x])
	{
        // 自底向上，先计算子树
		dfs(y);

        // 选了x，就不能选y
		dp[x][0] += max(dp[y][1], dp[y][0]);
		dp[x][1] += dp[y][0];
	}
	dp[x][1] += r[x];
}

void solve()
{
	int n; cin >> n;
	for(int i = 1; i <= n; i++) cin >> r[i];
	for(int i = 1; i < n; i++)
	{
		int u, v; cin >> u >> v;
		g[v].pb(u);
		fa[u] = v;
	}
	
	int rt = 0;
	for(int i = 1; i <= n; i++) if(!fa[i]) rt = i;
	
	dfs(rt);
	cout << max(dp[rt][0], dp[rt][1]);
}

int main()
{
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	
	int _ = 1;
	while(_--) solve();

	return 0;
}

// 7
// 1
// 1
// 1
// 1
// 1
// 1
// 1
// 1 3
// 2 3
// 6 4
// 7 4
// 4 5
// 3 5

// 5