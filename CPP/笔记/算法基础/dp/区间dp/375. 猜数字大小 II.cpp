// 这道题二分是陷阱，因为不断取中间得到的未必最小（详情可以看示例1），而应该去枚举选择每个位置的可能。
// dp[i][j]表示猜测数字区间[i,j]的最小成本，假设猜测数字k（i<=k<=j），那么成本为k+max(dp[i][k-1], dp[k+1][j])。
// 代码的实现是比较模板的，但是怎么想到用区间dp，怎么设计状态比较难想

const int INF = 0x3f3f3f3f;

class Solution {
public:
    int getMoneyAmount(int n) {
        vector dp(n + 7, vector<int> (n + 7));

        for(int len = 2; len <= n; ++len)
        {
            for(int i = 1, j = i + len - 1; j <= n; ++i, ++j)
            {
                dp[i][j] = INF;

                for(int k = i; k < j; ++k)
                    dp[i][j] = min(dp[i][j], max(dp[i][k - 1], dp[k + 1][j]) + k); // 最大值的最小值
            }
        }

        return dp[1][n];
    }
};

// 输入：n = 10
// 输出：16
// 解释：制胜策略如下：
// - 数字范围是 [1,10] 。你先猜测数字为 7 。
//     - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。
//     - 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。
//         - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。
//         - 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16 。
//         - 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16 。
//     - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。
//         - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。
//         - 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。
//             - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $5 。
//             - 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
//             - 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
//         - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。
//             - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $1 。
//             - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11 。
// 在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。


// 示例 2：
// 输入：n = 1
// 输出：0
// 解释：只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用。


// 示例 3：
// 输入：n = 2
// 输出：1
// 解释：有两个可能的数字 1 和 2 。
// - 你可以先猜 1 。
//     - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。
//     - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。
// 最糟糕的情况下，你需要支付 $1 。