//普通的完全背包：给硬币，求dp；而这道题是给最后的dp，求硬币

class Solution
{
public:
    vector<int> findCoins(vector<int> &numWays)
    {
        vector<int> ans, dp(numWays.size() + 7);

        dp[0] = 1;
        for (int i = 0; i < numWays.size(); i++)
        {
            int y = numWays[i];

            if (y == dp[i + 1]) continue; // 如果 numWays[i]= fl],说明所有和为的方案均由小于的元素组成，α 中没有。
            if (y ^ dp[i + 1] + 1) return {}; // 意味着可以单独一个数，贡献1个和为的方案，所以αns中一定有i+1

            for (int j = i + 1; j <= numWays.size(); j++) dp[j] += dp[j - i - 1]; //模拟普通完全背包
            ans.push_back(i + 1);
        }

        return ans;
    }
};

// 示例 1：
// 输入： numWays = [0,1,0,2,0,3,0,4,0,5]
// 输出： [2,4,6]
// 解释：
// 金额	方法数	解释
// 1	0	无法用硬币凑出总金额 1。
// 2	1	唯一的方法是 [2]。
// 3	0	无法用硬币凑出总金额 3。
// 4	2	可以用 [2, 2] 或 [4]。
// 5	0	无法用硬币凑出总金额 5。
// 6	3	可以用 [2, 2, 2]、[2, 4] 或 [6]。
// 7	0	无法用硬币凑出总金额 7。
// 8	4	可以用 [2, 2, 2, 2]、[2, 2, 4]、[2, 6] 或 [4, 4]。
// 9	0	无法用硬币凑出总金额 9。
// 10	5	可以用 [2, 2, 2, 2, 2]、[2, 2, 2, 4]、[2, 4, 4]、[2, 2, 6] 或 [4, 6]。


// 示例 2：
// 输入： numWays = [1,2,2,3,4]
// 输出： [1,2,5]
// 解释：
// 金额	方法数	解释
// 1	1	唯一的方法是 [1]。
// 2	2	可以用 [1, 1] 或 [2]。
// 3	2	可以用 [1, 1, 1] 或 [1, 2]。
// 4	3	可以用 [1, 1, 1, 1]、[1, 1, 2] 或 [2, 2]。
// 5	4	可以用 [1, 1, 1, 1, 1]、[1, 1, 1, 2]、[1, 2, 2] 或 [5]。


// 示例 3：
// 输入： numWays = [1,2,3,4,15]
// 输出： []
// 解释：
// 没有任何面值集合可以生成该数组。