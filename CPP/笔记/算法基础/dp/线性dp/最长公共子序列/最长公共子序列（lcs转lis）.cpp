#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1e5 + 7;
int a[N], b[N], c[N];

int main()
{
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	
	int n; cin >> n;
	
	//进行离散化处理，用第二个串来匹配第一个串，看能匹配多少
	//比如他的样例：3 2 1 4 5 我们把他变成 1 2 3 4 5 用一个数组记录一下每个数字变成了什么，相当于离散化了一下3-1；2-2；1-3；4-4；5-5； 
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i];
		c[a[i]] = i;
	}
	for(int i = 1; i <= n; i++)
	{
		int x; cin >> x;
		b[i] = c[x];
	}
	
	//求lis的模板 
	vector<int> v;
	v.push_back(b[1]);
	
	for(int i = 2; i <= n; i++)
	{
		if(b[i] > v.back()) v.push_back(b[i]);
		else v[lower_bound(v.begin(), v.end(), b[i]) - v.begin()] = b[i];
	}
	
	cout << v.size();
	
	return 0;
}

//5 
//3 2 1 4 5
//1 2 3 4 5
//
//3

//关于为什么可以转化成LIS问题，这里提供一个解释。
//
//A:3 2 1 4 5
//
//B:1 2 3 4 5
//
//我们不妨给它们重新标个号：把3标成a,把2标成b，把1标成c……于是变成：
//
//A: a b c d e
//B: c b a d e
//
//这样标号之后，LCS长度显然不会改变。但是出现了一个性质：
//
//两个序列的子序列，一定是A的子序列。而A本身就是单调递增的。
//因此这个子序列是单调递增的。
//
//换句话说，只要这个子序列在B中单调递增，它就是A的子序列。
//
//哪个最长呢？当然是B的LIS最长。
//
//自此完成转化。

//ps：这种转化思路通常适用于两个序列是同一组元素的不同排列的情况，也可以是在字符串中寻找元素不重复的模式串。
//例如，给定的两个序列都是 1 到 n 的一个全排列，此时可以通过重新标号（离散化）的方式，将 LCS 问题转化为 LIS 问题。
//它并不通用，因为其依赖于上述特定条件。如果两个序列的元素组成不同，或者没有这种特定的对应关系，就无法直接进行这种转化。
//比如，一个序列是 1, 2, 3, 4, 5，另一个序列是 5, 6, 7, 8, 9，就不能通过这种方法将 LCS 转化为 LIS。
