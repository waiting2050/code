// 比普通的股票交易多了做空，因此也要多一个状态，但是注意返回时要完成交易，不能在卖出还未买回的时候结束，即不能返回dp[n][k+1][2]
// dp[i][j][0,1,2]分别表示到第i天准备至多交易j次此时（未持有/持有/待买回）的利润

// 为什么返回k+1，假如返回k，当天交易可能没完全结束，比如手上dp[n][k][1]还持有股票，但实际当天是可以卖出的
// 也就是说应该返回dp[n][k][1]+prices[n-1]，因此不如返回dp[n][k+1][0]，这样等于第k+1次交易尚未开始，而k次交易已经
// 完全结束。
// 还有一种解释，交易需要买卖，那你怎么定义一次交易开始呢，也就是什么时候j+1呢，按本题写法，只有开始买（普通交易）或
// 开始卖（做空）时+1，但此时并不是+1就结束交易了，还需要卖出/买入才真正算结束交易，即第三维为0时真正结束上一次交易
// 也就是说dp[i][j][0]表示上一次dp[i-1][j-1][1],dp[i-1][j-1][2]结束，实际从状态转移方程也可以发现这一点

class Solution 
{
public:
    long long maximumProfit(vector<int>& prices, int k) 
    {
        int n = prices.size();
        vector dp(n + 7, vector<vector<long long>> (k + 7, vector<long long> (3, -0x3f3f3f3f3f3f3f3f)));

        for(int i = 1; i <= k + 1; i++) dp[0][i][0] = 0;
        for(int i = 0; i < n; i++)
        {
            for(int j = 1; j <= k + 1; j++)
            {
                dp[i + 1][j][0] = max({dp[i][j][0], dp[i][j][1] + prices[i], dp[i][j][2] - prices[i]});
                dp[i + 1][j][1] = max(dp[i][j][1], dp[i][j - 1][0] - prices[i]);
                dp[i + 1][j][2] = max(dp[i][j][2], dp[i][j - 1][0] + prices[i]);
            }
        }

        return dp[n][k + 1][0];
    }
};

// 示例 1:
// 输入: prices = [1,7,9,8,2], k = 2
// 输出: 14
// 解释:
// 我们可以通过 2 笔交易获得 14 美元的利润：
// 一笔普通交易：第 0 天以 1 美元买入，第 2 天以 9 美元卖出。
// 一笔做空交易：第 3 天以 8 美元卖出，第 4 天以 2 美元买回。


// 示例 2:
// 输入: prices = [12,16,19,19,8,1,19,13,9], k = 3
// 输出: 36
// 解释:
// 我们可以通过 3 笔交易获得 36 美元的利润：
// 一笔普通交易：第 0 天以 12 美元买入，第 2 天以 19 美元卖出。
// 一笔做空交易：第 3 天以 19 美元卖出，第 4 天以 8 美元买回。
// 一笔普通交易：第 5 天以 1 美元买入，第 6 天以 19 美元卖出。