// 本题感觉开始上了一点难度，已经到新手的门槛了，感觉不是div3本地人能做的题。
// 首先要对这个题目的题意有一个定性的感觉。这道题给了定义f(x, y)。抽象来说就是你要找到一个数组z，z的前缀最大值要与x一样。
// 而你的z又要尽可能与数组y更加接近(相等的位置更多)。其中同位置相等的次数的最大值就是f(x,y)
// 因此抽象来说, f(x,y)其实表示的是能找到的最大“匹配度”。
// 那么我们就要想，为什么我们不能直接把y放上去（显然），是什么影响了这个操作？
// 有哪些位置是确定的，有哪些位置是可以随意的？
// 这道题需要我们找到所有区间的f(x,y)的总和，所以我们显然需要深刻思考这个f(x,y)包含的性质。
 
// -----------
// 有了一个基础的思想之后，我们可以去考虑刚才我们想到的问题。
// 可以轻松的发现，对于一个确定的区间，在导致x数组的前缀最大值增加的位置，我们的z数组的值是确定的。
// 例如 x = [(6), 2, 3, (8), 7, 6, 1, (9), 3, 2]
// 括号内的就是z数组中必须要相同的数字，这种点我们在思考的时候可以叫他 “确定点”
// 而其他位置则是可以与x不同的，这些数字我们可以叫他 “不确定点”。
 
// 来思考一下匹配情况，
// - 对于确定点，因为我们必须要设置为x[i], 因此它必须要与y[i]相同，我们才能获得"一次匹配"
// - 对于不确定点，我们可以设置为任意一个不大于前缀最大值的数字，因此如果y[i] <= pre[i]，则可以获得“一次匹配“
 
// ------------
// 那么当前我们考虑了一个确定的数组的匹配情况怎么获取，接下来我们要把它扩展到所有数组的总和。
// 这种问题我们大概率会去考虑”总匹配次数“，而非遍历所有数组来解决。这也是我刚才在讨论的时候说“一次匹配”的原因。
 
// 这类问题有一种经典的思想是，去考虑每个位置 i 在所有的区间中，总共产生了多少次匹配。然后把它们求和即可得到最终的匹配总数。
// 例如 x = [(6), 2, 3, (8), 4, 1, 3, 6, (9), 3, 2]
//                                ^
// 我们去考虑这个3在所有区间中的匹配总数
// - 1. 显然的，如果左端点在(8)之前或在(8)的位置，右端点在3或3的右边（是否在9的右边其实不重要），此时3是一个不确定点
//      如果y[i] <= 8的话，其最答案的总贡献为 4 * 5 = 20 (左边有4个区间起点，右边有3个区间终点)
// - 2. 如果左端点在(8)的右边，3的左边或3的位置，右端点仍然在3或3的右边，此时我们发现
//  - i. 如果左端点在4的位置，3仍然是个不定点，y[i] <= 4才可匹配
//  - ii. 如果左端点在1或3的位置，3就是一个确定点了，y[i]必须恰好等于3才可匹配。
 
// ----------
// 在我们试着举了一些例子之后，我们可以扩展一下这个3的左边的情况，让它更复杂一点。
// 例如: (10) 8 6 4 1 2 3 (12)
// 这个时候，对于这个3来说，就与他的y[i]是多少关系非常密切了，这取决于对于哪些起点，3可以产生贡献。
// 如果 y[i] = 7, 那么起点必须为10或者8才可以产生贡献，
// 如果 y[i] = 5, 则起点10，8，6都可以产生贡献
// 如果 y[i] = 2, 则起点10,8,6,4可以产生贡献
// 如果 y[i] = x[i] = 3, 则起点 10,8,6,4,1,2都可以产生贡献。
 
// ----------
// 此时我们就可以得到一个很深刻的结论：如果上一个大于等于y[i]的数字在j的位置
// - 起点在[1,j]，终点在[i,n]时，第i个位置都能产生1点贡献 （第i个点作为不确定点）
// - 起点在[j+1,i], 终点在[i,n]时，仅有y[i] = x[i]的时候，第i个位置才能产生1点贡献
//     换句话说，我们发现y[i] = x[i]时，我们直接设置z[i] = y[i]即可，在所有情况下都可以获取贡献
 
// ----------
// 那么代码实现的时候，我们需要找到第[1,i-1]中最后一个x[j] > y[i]的j
// 此时我们可以用点树状数组啊，二维数点啊之类的知识。类似于HH的项链这道题（？）。
// 这是一个单点修改，前缀查询（最大值）的树状数组
// 如果我们发现 x[i] = 6，我们就去将第6个位置修改成i
// 如果我们要查比7小的数字，我们就查树状数组[1, 7]的最大值，此时刚才6的位置修改的i就会在里面
// 如果我们要查比5小的数字，我们就[1,5]的最大值，此时i就不在里面。
 
// 但是发现一件很抽象的事，这里要找的是比a[i]大的数字的位置，所以如果当前位置是7，我们其实要找的是 [7,+INF]的最大值
// 我也不知道咋办，所以这里可能不是最优解。
// 我是想把7转化为 2n+1 -7 （因为INF其实是2n）这样就变成前缀最大值了
// 当然也可以掏出一个线段树，不过我不想掏

// Problem: CF 2137 F
// Contest: Codeforces - Codeforces Round 1047 (Div. 3)
// URL: https://codeforces.com/contest/2137/problem/F
// Memory Limit: 256 MB
// Time Limit: 3000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h> 
using namespace std;
 
const int maxn = 2e6 + 5;
typedef long long ll;
 
int x[maxn], f[maxn], y[maxn];
ll n;
int lowbit(int x) {
    return x & -x;
}
 
void update(int p, int x) {
    while (p <= 2 * n + 1) {
        f[p] = max(f[p], x);
        p += lowbit(p);
    }
}
 
int query(int p) {
    int mx = 0;
    while (p) {
        mx = max(mx, f[p]);
        p -= lowbit(p);
    }
    return mx;
}
 
void solve() {
    cin >> n; 
    for (int i = 0; i <= 3 * n + 1; i++) f[i] = 0;
    for (int i = 1; i <= n; i++) cin >> x[i];
    for (int i = 1; i <= n; i++) cin >> y[i];
 
 
    ll ans = 0;
 
    for (ll i = 1; i <= n; i++) {
        // 修改ans
        if (x[i] == y[i]) ans += i * (n - i + 1);
        else {
            ll lst = query(2 * n + 1 - max(x[i], y[i])); // 如果没有的话是0，相当于没有方案
         
            // cout << lst << " ";
            ans += lst * (n - i + 1);
        }
        // cout << ans << ' ';
        // cout << 2 * n + 1 - x[i] << " ";
        // 修改最大值
        update(2 * n + 1 - x[i], i);
    }
    cout << ans << endl;
 
}
 
int main() {
    int T;
    cin >> T;
    while (T--) solve();
}
