// 参考45.跳跃游戏 ⅱ，区别在于这个不是一定能到达，以及给的范围是某点前后区间，而不是从某个点之后的区间。

func minTaps(n int, ranges []int) int {
    r := make([]int, n + 1)
    l := 0

    for idx, val := range ranges { // 转换为某点之后的区间
        l = max(0, idx - val)
        r[l] = max(r[l], idx + val)
    }

    mx, cur, ans := 0, 0, 0
    for i := 0; i < n; i++ {
        mx = max(mx, r[i])
        if i == cur {
            if mx == i { // 无法到达下一个位置
                return -1
            }

            cur = mx
            ans++
        }
    }
    return ans
}

// 示例 1：
// 输入：n = 5, ranges = [3,4,1,1,0,0]
// 输出：1
// 解释：
// 点 0 处的水龙头可以灌溉区间 [-3,3]
// 点 1 处的水龙头可以灌溉区间 [-3,5]
// 点 2 处的水龙头可以灌溉区间 [1,3]
// 点 3 处的水龙头可以灌溉区间 [2,4]
// 点 4 处的水龙头可以灌溉区间 [4,4]
// 点 5 处的水龙头可以灌溉区间 [5,5]
// 只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。


// 示例 2：
// 输入：n = 3, ranges = [0,0,0,0]
// 输出：-1
// 解释：即使打开所有水龙头，你也无法灌溉整个花园。